diff --git a/data/gm_loader.py b/data/gm_loader.py
new file mode 100644
index 0000000..e61ab82
--- /dev/null
+++ b/data/gm_loader.py
@@
+import numpy as np
+
+
+class GradEdgeStream:
+    """Yield ('pos' | 'neg', (u, v, t, weight)) from edge_list_grad.npy."""
+
+    def __init__(self, npy_path: str):
+        self.events = np.load(npy_path)  # (u,v,t,sign,weight), sorted by t
+
+    def __iter__(self):
+        for u, v, t, sign, w in self.events:
+            chan = "pos" if sign > 0 else "neg"
+            yield chan, (int(u), int(v), int(t), float(w))
+
diff --git a/models/dual_link_encoder.py b/models/dual_link_encoder.py
new file mode 100644
index 0000000..98fb4c9
--- /dev/null
+++ b/models/dual_link_encoder.py
@@
+import torch
+import torch.nn as nn
+
+
+class SingleLinkEncoder(nn.Module):
+    """(Δt, weight) → time-embed × weight → 1-layer MLP → mean-pool."""
+
+    def __init__(self, time_dim: int, hid_dim: int):
+        super().__init__()
+        self.time_emb = nn.Linear(1, time_dim, bias=False)
+        self.proj = nn.Linear(time_dim, hid_dim, bias=False)
+
+    def forward(self, seq):
+        # seq: [B, L, 2]  (Δt, weight)
+        dt, w = seq[..., :1], seq[..., 1:2]
+        te = self.time_emb(dt)
+        z = self.proj(te * w).mean(dim=1)
+        return z
+
+
+class DualLinkEncoder(nn.Module):
+    """Run SingleLinkEncoder on positive & negative channels and concatenate."""
+
+    def __init__(self, time_dim: int, hid_dim: int):
+        super().__init__()
+        self.pos_enc = SingleLinkEncoder(time_dim, hid_dim)
+        self.neg_enc = SingleLinkEncoder(time_dim, hid_dim)
+
+    def forward(self, pos_seq, neg_seq):
+        z_pos = self.pos_enc(pos_seq)
+        z_neg = self.neg_enc(neg_seq)
+        return torch.cat([z_pos, z_neg], dim=-1)
+
diff --git a/models/mixer_head.py b/models/mixer_head.py
index e3ab123..a9c4def 100644
--- a/models/mixer_head.py
+++ b/models/mixer_head.py
@@
-        in_dim = k_hops + 1
-        self.token_mix = nn.Linear(in_dim, hidden_dim)
+        in_dim = 2 * (k_hops + 1)               # 双通道
+        self.token_mix = nn.Linear(in_dim, hidden_dim)
